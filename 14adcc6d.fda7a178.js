(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{141:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return d}));var o=t(0),a=t.n(o);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=a.a.createContext({}),p=function(e){var n=a.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):c({},n,{},e)),t},u=function(e){var n=p(e.components);return a.a.createElement(i.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},b=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,i=l(e,["components","mdxType","originalType","parentName"]),u=p(t),b=o,d=u["".concat(s,".").concat(b)]||u[b]||m[b]||r;return t?a.a.createElement(d,c({ref:n},i,{components:t})):a.a.createElement(d,c({ref:n},i))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=b;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,s[1]=c;for(var i=2;i<r;i++)s[i]=t[i];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},99:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return i}));var o=t(1),a=(t(0),t(141));const r={title:"Notes"},s={id:"music/notes",title:"Notes",description:"## Playing Different Notes",source:"@site/book/music/notes.md",permalink:"/book/music/notes",sidebar:"main",previous:{title:"JavaScript",permalink:"/book/primers/javascript"},next:{title:"Scales",permalink:"/book/music/scales"}},c=[{value:"Playing Different Notes",id:"playing-different-notes",children:[{value:"Pitch Shifting",id:"pitch-shifting",children:[]},{value:"Samplers and Sample Libraries",id:"samplers-and-sample-libraries",children:[]}]},{value:"Mapping Notes to Samples",id:"mapping-notes-to-samples",children:[{value:"Enharmonic Notes",id:"enharmonic-notes",children:[]},{value:"Sample Map",id:"sample-map",children:[]},{value:"Sampler v2",id:"sampler-v2",children:[]}]},{value:"Controlling Notes",id:"controlling-notes",children:[{value:"Volume",id:"volume",children:[]},{value:"Envelope",id:"envelope",children:[]},{value:"Compression",id:"compression",children:[]},{value:"Reverb",id:"reverb",children:[]},{value:"Sampler v3",id:"sampler-v3",children:[]}]},{value:"Learning",id:"learning",children:[]}],l={rightToc:c};function i({components:e,...n}){return Object(a.b)("wrapper",Object(o.a)({},l,n,{components:e,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"playing-different-notes"},"Playing Different Notes"),Object(a.b)("p",null,"Our musical options would be quite limited if we could only play middle C, so\nlet's explore ways to make other notes."),Object(a.b)("h3",{id:"pitch-shifting"},"Pitch Shifting"),Object(a.b)("p",null,"One approach we could take is to adjust the pitch of our sample to emulate\ndifferent notes. Thanks to the intricacies of frequency and the human ear, we\nperceive a sample played at twice the speed to be twice the pitch."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const context = new AudioContext()\n\n// Half speed = 22,050 Hz = -1 octave = C3\nconst c3 = context.createBufferSource()\nc3.buffer = audioBuffer\nc3.playbackRate.value = 0.5\n\n// Full speed = 44,100 Hz = C4\nconst c4 = context.createBufferSource()\nc4.buffer = audioBuffer\nc4.playbackRate.value = 1.0\n\n// Double speed = 88,200 Hz = +1 octave = C5\nconst c5 = context.createBufferSource()\nc5.buffer = audioBuffer\nc5.playbackRate.value = 2.0\n")),Object(a.b)("p",null,"This works surprisingly well within a limited range, but pitch shifting too much\ncan start to sound unnatural, especially for real instruments, where we have an\nexpectation of how they should sound at different pitches."),Object(a.b)("h3",{id:"samplers-and-sample-libraries"},"Samplers and Sample Libraries"),Object(a.b)("p",null,"A better approach, and one used in most music production, is to have a sample\nfor each note. This brings us to the topic of samplers and sample libraries."),Object(a.b)("p",null,"A sampler, at its most basic, is an instrument that can load and play back\nsamples. You can assign samples to physical triggers such as the keys of a\nkeyboard, so that when pressing the key, the assigned sample is played."),Object(a.b)("p",null,"Sample libraries (or sample packs) are bundles of samples, usually with a\nmetadata file that tells the sampler how the individual sample files map to\nkeyboard notes. A library maker records each individual note of an instrument,\noften at various velocities (e.g. how hard a piano key is hit) and with\ndifferent techniques (e.g. whether a violin string is bowed or plucked) to\ncapture the full range of sounds the instrument can make. Whilst this can't\nmatch the subtleties of how a musician might play, it's usually good enough for\ncomposition."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note:")," Sample libraries don't always contain recordings of all possible\nnotes, but combine a subset of samples with the pitch shifting trick mentioned\nabove.")),Object(a.b)("p",null,"Most sample libraries are commercial products, often bundled with software\nsamplers, but there are several libraries available for free use. ",Object(a.b)("strong",{parentName:"p"},"Tuplet"),"\nincludes a range of samples for different instruments, which we'll be using\nthroughout this book. It includes a\n",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/meleyal/tuplet/tree/master/src/samples/piano"}),"piano")," sample\npack, which contains recordings of all the notes of a piano (A0\u2013C8)."),Object(a.b)("p",null,"###\xa0Sampler v1"),Object(a.b)("p",null,"We've already seen how we can load and play back a single sample. We can use the\nsame principles to load and play back an entire set of samples."),Object(a.b)("p",null,"Let's create a ",Object(a.b)("inlineCode",{parentName:"p"},"sampler()")," function that takes an audio context and a map of\nsamples we want to load, and returns a function for playing them back:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const sampler = async (context, samples) => {\n  const buffers = await Promise.all(\n    Object.keys(samples).map((note) =>\n      fetch(samples[note])\n        .then((response) => response.arrayBuffer())\n        .then((arrayBuffer) => context.decodeAudioData(arrayBuffer))\n        .then((buffer) => Object.create({ note, buffer }))\n    )\n  )\n\n  return (note) => {\n    const notes = typeof note == 'string' ? [note] : note\n    const now = context.currentTime\n    notes.map((n) => {\n      const buffer = buffers.find((b) => b.note == n).buffer\n      const sourceNode = context.createBufferSource()\n      sourceNode.buffer = buffer\n      sourceNode.start(now)\n      sourceNode.connect(context.destination)\n    })\n  }\n}\n;(async () => {\n  const context = new AudioContext()\n\n  const piano = await sampler(context, {\n    C4: 'samples/piano/c4.mp3',\n    D4: 'samples/piano/d4.mp3',\n    E4: 'samples/piano/e4.mp3',\n    F4: 'samples/piano/f4.mp3',\n    G4: 'samples/piano/g4.mp3',\n    // ...etc.\n  })\n\n  // Single C note\n  piano('C4')\n\n  // C major chord\n  piano(['C4', 'E4', 'G4'])\n})()\n")),Object(a.b)("h2",{id:"mapping-notes-to-samples"},"Mapping Notes to Samples"),Object(a.b)("p",null,"Rather than writing out a sample map of 88 notes by hand, we can automate this\nprocess with a ",Object(a.b)("inlineCode",{parentName:"p"},"sampleMap()")," function. But first, we'll need to understand a\nsmall nuance of sample libraries."),Object(a.b)("h3",{id:"enharmonic-notes"},"Enharmonic Notes"),Object(a.b)("p",null,"If you inspect the piano samples, you might notice that they don't seem to\nactually include ",Object(a.b)("em",{parentName:"p"},"all")," of the notes we need:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-text"}),".\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 c4.mp3\n\u251c\u2500\u2500 ... <- where is c#4.mp3?\n\u251c\u2500\u2500 db4.mp3\n\u251c\u2500\u2500 d4.mp3\n\u251c\u2500\u2500 ...\n")),Object(a.b)("p",null,"Recall from the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"../primers/music"}),"Music")," chapter that some notes can be sharp\n(C#, half a semitone above C) or flat (Db, half a semitone below D). Looking at\nour keyboard, we can see that these are actually the same note:"),Object(a.b)("p",null,Object(a.b)("img",Object(o.a)({parentName:"p"},{src:"/img/sampler/enharmonic.svg",alt:null}))),Object(a.b)("p",null,'These are known as "enharmonic" notes, which just means they are the same note\nwritten in a different way. We can write a simple ',Object(a.b)("inlineCode",{parentName:"p"},"enharmonic()")," function to\nconvert in either direction:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const enharmonic = (note) => {\n  switch (note) {\n    case 'A#':\n      return 'Bb'\n    case 'Bb':\n      return 'A#'\n    case 'C#':\n      return 'Db'\n    case 'Db':\n      return 'C#'\n    case 'D#':\n      return 'Eb'\n    case 'Eb':\n      return 'D#'\n    case 'F#':\n      return 'Gb'\n    case 'Gb':\n      return 'F#'\n    case 'G#':\n      return 'Ab'\n    case 'Ab':\n      return 'G#'\n    default:\n      return note\n  }\n}\n\nenharmonic('C#') // => Db\nenharmonic('Db') // => C#\n")),Object(a.b)("h3",{id:"sample-map"},"Sample Map"),Object(a.b)("p",null,"With our knowledge of enharmonics in hand, let's write a ",Object(a.b)("inlineCode",{parentName:"p"},"sampleMap()")," function\nthat maps the 88 note names to their respective sample files, taking into\naccount enharmonic naming (e.g. ",Object(a.b)("inlineCode",{parentName:"p"},"C#4")," maps to ",Object(a.b)("inlineCode",{parentName:"p"},"db4.mp3"),")."),Object(a.b)("p",null,"Different sample libraries may use different naming conventions and file\nformats, so to account for that, our function will take a ",Object(a.b)("inlineCode",{parentName:"p"},"pathFn")," function to\nconstruct the final url to the sample."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note:")," Here we're mapping over all octaves and notes, but most instruments\nhave a more limited range than the piano. A fully-fledged ",Object(a.b)("inlineCode",{parentName:"p"},"sampleMap()"),"\nimplementation might allow for specifying a given range to map over.")),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),'const { enharmonic } = tuplet\n\nconst sampleMap = (pathFn) => {\n  const notes = \'C,C#,D,D#,E,F,F#,G,G#,A,A#,B\'.split(\',\')\n  const octaves = [1, 2, 3, 4, 5, 6, 7]\n\n  return notes\n    .flatMap((note) =>\n      octaves.map((octave) => {\n        const name = `${note}${octave}`\n        return { [name]: pathFn(note, octave) }\n      })\n    )\n    .reduce((a, b) => Object.assign(a, b), {})\n}\n\nconst samples = sampleMap((note, octave) => {\n  const baseUrl = \'https://example.com\'\n  const noteName = enharmonic(note).toLowerCase()\n  return `${baseUrl}/samples/piano/${noteName}${octave}.mp3`\n})\n\nconsole.log(samples)\n\n// Logs:\n//\n//  {\n//    A1: "http://localhost:3001/samples/piano/a1.mp3",\n//    A2: "http://localhost:3001/samples/piano/a2.mp3",\n//    A3: "http://localhost:3001/samples/piano/a3.mp3",\n//    A4: "http://localhost:3001/samples/piano/a4.mp3",\n//    A5: "http://localhost:3001/samples/piano/a5.mp3",\n//    ...etc.\n//  }\n')),Object(a.b)("p",null,"###\xa0Note Numbers"),Object(a.b)("p",null,"When we get into generating notes and patterns later in the book, it will be\nuseful to be able to translate between note names and numbers. MIDI, which we\ncovered briefly in the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"../primers/music"}),"Music")," chapter, already has a\nconvention for note numbers, so we'll use that."),Object(a.b)("p",null,"As we know, a piano keyboard has 88 keys spanning 7 octaves, going from A0 to\nC8. MIDI note numbers go from 0 (C-1) to 127 (G9), which encompasses the full\nrange of notes produced by\n",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Range_(music)"}),"most instruments"),"."),Object(a.b)("p",null,"Let's write two functions ",Object(a.b)("inlineCode",{parentName:"p"},"noteNumber()")," to get the MIDI note number given a\nnote name, and ",Object(a.b)("inlineCode",{parentName:"p"},"noteName()")," to get the the note name from the MIDI note number."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const noteNumber = (name) => {\n  const re = /(?<note>\\w(\\w|\\W)?)(?<octave>\\d{1})/u\n  const {\n    groups: { note, octave },\n  } = re.exec(name)\n\n  const notes = {\n    C: 0,\n    'C#': 1,\n    Db: 1,\n    D: 2,\n    'D#': 3,\n    Eb: 3,\n    E: 4,\n    F: 5,\n    'F#': 6,\n    Gb: 6,\n    G: 7,\n    'G#': 8,\n    Ab: 8,\n    A: 9,\n    'A#': 10,\n    Bb: 10,\n    B: 11,\n  }\n\n  return notes[note] + 12 + 12 * octave\n}\n\nnoteNumber('C0') // => 12\nnoteNumber('C4') // => 60\nnoteNumber('Gb4') // => 66\nnoteNumber('G4') // => 67\nnoteNumber('A4') // => 69\nnoteNumber('A#4') // => 70\nnoteNumber('Bb4') // => 70\nnoteNumber('B4') // => 71\n")),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const noteName = (num) => {\n  const numbers = {\n    0: 'C',\n    1: 'C#/Db',\n    2: 'D',\n    3: 'D#/Eb',\n    4: 'E',\n    5: 'F',\n    6: 'F#/Gb',\n    7: 'G',\n    8: 'G#/Ab',\n    9: 'A',\n    10: 'A#/Bb',\n    11: 'B',\n  }\n\n  // Normalize the note number so it maps to our 0-indexed `numbers` map.\n  const norm = num - 12\n\n  // Dividing the note number by 12 (the number of notes in an octave) gives us\n  // the octave that the note falls into.\n  const octave = Math.floor(norm / 12)\n\n  // Remove the octaves to get a valid index into our numbers map.\n  const note = norm - 12 * octave\n\n  return numbers[note]\n    .split('/')\n    .map((name) => name + octave)\n    .join('/')\n}\n\nnoteName(12) // => C0\nnoteName(14) // => D0\nnoteName(21) // => A0\nnoteName(24) // => C1\nnoteName(60) // => C4\nnoteName(80) // => G#5/Ab5\nnoteName(107) // => B7\n")),Object(a.b)("h3",{id:"sampler-v2"},"Sampler v2"),Object(a.b)("p",null,"Putting this all together, we can combine our ",Object(a.b)("inlineCode",{parentName:"p"},"sampleMap()")," function with a\nmodified version of ",Object(a.b)("inlineCode",{parentName:"p"},"sampler()")," that can play notes given either a note name or\nnote number:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const { noteName, enharmonic, sampleMap } = tuplet\n\nconst sampler = async (context, samples) => {\n  const buffers = await Promise.all(\n    Object.keys(samples).map((note) =>\n      fetch(samples[note])\n        .then((response) => response.arrayBuffer())\n        .then((arrayBuffer) => context.decodeAudioData(arrayBuffer))\n        .then((buffer) => Object.create({ note, buffer }))\n    )\n  )\n\n  const parseNote = (note) => {\n    if (Array.isArray(note)) {\n      return note.map(parseNote)\n    } else if (typeof note === 'number') {\n      return [noteName(note)]\n    } else {\n      return [note]\n    }\n  }\n\n  return (note) => {\n    const notes = parseNote(note)\n    const now = context.currentTime\n    notes.map((n) => {\n      const buffer = buffers.find((b) => b.note == n).buffer\n      const sourceNode = context.createBufferSource()\n      sourceNode.buffer = buffer\n      sourceNode.start(now)\n      sourceNode.connect(context.destination)\n    })\n  }\n}\n\n;(async () => {\n  const context = new AudioContext()\n\n  const samples = sampleMap((note, octave) => {\n    const baseUrl = 'https://example.com'\n    const noteName = enharmonic(note).toLowerCase()\n    return `${baseUrl}/samples/piano/${noteName}${octave}.mp3`\n  })\n\n  const piano = await sampler(context, samples)\n\n  // Single C note\n  piano('C4')\n\n  // C major chord\n  piano(['C4', 'E4', 'G4'])\n\n  // Single C note\n  piano(60)\n\n  // C major chord\n  piano([60, 64, 67])\n})()\n")),Object(a.b)("h2",{id:"controlling-notes"},"Controlling Notes"),Object(a.b)("p",null,"This is a good start, but our sampler is still missing a few essential features."),Object(a.b)("p",null,"Currently, once triggered, our notes play at full volume from start to finish.\nThis is equivalent to playing a piano and pressing each key with the same\nvelocity and holding it for the same length of time."),Object(a.b)("p",null,"To model how a real piano is played, where notes may be quiet, loud, short, or\nlong, we need a way to control our samples as they are playing."),Object(a.b)("h3",{id:"volume"},"Volume"),Object(a.b)("p",null,"We can control the volume of a sample with a\n",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/GainNode"}),Object(a.b)("inlineCode",{parentName:"a"},"GainNode")),", which\nchanges the volume of any signal passing through it according to its\n",Object(a.b)("inlineCode",{parentName:"p"},"gain.value"),"."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"We use gain and volume interchangeably here, but technically ",Object(a.b)("em",{parentName:"p"},"gain")," is the\nchange applied, resulting in a different ",Object(a.b)("em",{parentName:"p"},"volume"),".")),Object(a.b)("p",null,"Returning back to our simple oscillator example, we can control its volume by\ninserting a ",Object(a.b)("inlineCode",{parentName:"p"},"GainNode")," between it and our speakers."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const context = new AudioContext()\nconst osc = context.createOscillator()\nconst volume = context.createGain()\n\nosc.connect(volume)\nvolume.connect(context.destination)\n\nvolume.gain.value = 0.5\nosc.start()\n")),Object(a.b)("h3",{id:"envelope"},"Envelope"),Object(a.b)("p",null,"To control how long a note lasts, we can use what's known as an ",Object(a.b)("em",{parentName:"p"},"envelope"),". An\nenvelope controls how a sound evolves over time, and is broken down into four\nphases:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Attack: when a note is triggered, how long it takes to reach full volume."),Object(a.b)("li",{parentName:"ul"},"Decay: how long it takes to drop to the sustain level."),Object(a.b)("li",{parentName:"ul"},"Sustain: the constant volume after decay until a note is released."),Object(a.b)("li",{parentName:"ul"},"Release: how quickly the sound fades after a note is released.")),Object(a.b)("p",null,"These four phases define what's known as an ",Object(a.b)("em",{parentName:"p"},"ADSR envelope"),". For our purposes,\nwe can simplify this down to just the attack and release phases, which will\nallow us to control how a sound peaks, and how long it lasts, known as an ",Object(a.b)("em",{parentName:"p"},"AR\nenvelope"),":"),Object(a.b)("p",null,Object(a.b)("img",Object(o.a)({parentName:"p"},{src:"/img/notes/envelopes.svg",alt:null}))),Object(a.b)("p",null,"Envelopes can be modelled with a ",Object(a.b)("inlineCode",{parentName:"p"},"GainNode"),", taking advantage of the fact that\nits ",Object(a.b)("inlineCode",{parentName:"p"},"gain")," property is an\n",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/AudioParam"}),Object(a.b)("inlineCode",{parentName:"a"},"AudioParam"))," that\ncan be controlled over time:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const context = new AudioContext()\nconst osc = context.createOscillator()\nconst envelope = context.createGain()\n\nconst now = context.currentTime\nconst zero = 0.00001 // value must be positive for exponentialRamp\nconst volume = 1 // full volume\nconst attack = 1 // note takes 1 second to reach full volume\nconst release = 3 // note lasts for 3 seconds\n\nenvelope.gain\n  .setValueAtTime(0, now)\n  .linearRampToValueAtTime(volume, now + attack)\n  .exponentialRampToValueAtTime(zero, now + attack + release)\n\nosc.connect(envelope)\nenvelope.connect(context.destination)\nosc.start()\n")),Object(a.b)("p",null,"###\xa0Panning"),Object(a.b)("p",null,"Panning describes where a sound is placed in the stereo field, and emulates the\neffect of sounds coming from different physical spaces. When mixing different\nsounds together, panning can give each sound it's own place in the mix."),Object(a.b)("p",null,'For our purposes, we\'re only working with two audio channels: left and right.\nPanning essentially just controls how "much" of a sound goes to each channel.'),Object(a.b)("p",null,"To pan sounds we can use a\n",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/StereoPannerNode"}),Object(a.b)("inlineCode",{parentName:"a"},"StereoPannerNode")),".\nSetting its ",Object(a.b)("inlineCode",{parentName:"p"},"pan.value")," determines where the sound is panned, ranging from ",Object(a.b)("inlineCode",{parentName:"p"},"-1"),"\nbeing fully left, ",Object(a.b)("inlineCode",{parentName:"p"},"0")," being centre, to ",Object(a.b)("inlineCode",{parentName:"p"},"1")," being fully right."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const context = new AudioContext()\nconst osc = context.createOscillator()\nconst panner = context.createStereoPanner()\n\npanner.pan.value = -1 // fully left\n\nosc.connect(panner)\npanner.connect(context.destination)\nosc.start()\n")),Object(a.b)("h3",{id:"compression"},"Compression"),Object(a.b)("p",null,"Compression, in simple terms, is the process of modifying, or ",Object(a.b)("em",{parentName:"p"},"limiting"),", the\nquietness and/or loudness of a sound signal."),Object(a.b)("p",null,"When combining multiple sounds, their volumes (or ",Object(a.b)("em",{parentName:"p"},"amplitudes"),") are added\ntogether, which can result in distortion if their combined amplitudes exceed the\nrange of our speakers. By running our audio signal through a compressor, we can\nensure that the resulting signal never exceeds or drops below a given threshold."),Object(a.b)("p",null,"The example below shows combining two oscillators without compression. If you\nturn up your volume, you should notice that the sound starts to distort at some\npoint:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const context = new AudioContext()\nconst osc1 = context.createOscillator()\nconst osc2 = context.createOscillator()\n\nosc1.frequency.value = 440\nosc2.frequency.value = 880\n\nosc1.connect(context.destination)\nosc2.connect(context.destination)\n\nosc1.start()\nosc2.start()\n")),Object(a.b)("p",null,"Compare this with the example below where we run both oscillators through a\ncompressor. Even when increasing the volume to maximum, there should be no\ndistortion:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const context = new AudioContext()\nconst now = context.currentTime\n\nconst osc1 = context.createOscillator()\nconst osc2 = context.createOscillator()\nconst compressor = context.createDynamicsCompressor()\n\nosc1.frequency.value = 440\nosc2.frequency.value = 880\n\ncompressor.threshold.setValueAtTime(-50, now)\ncompressor.knee.setValueAtTime(40, now)\ncompressor.ratio.setValueAtTime(12, now)\ncompressor.attack.setValueAtTime(0, now)\ncompressor.release.setValueAtTime(0.25, now)\n\nosc1.connect(compressor)\nosc2.connect(compressor)\ncompressor.connect(context.destination)\n\nosc1.start()\nosc2.start()\n")),Object(a.b)("h3",{id:"reverb"},"Reverb"),Object(a.b)("p",null,"TODO: Impulse responses."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const reverbNode = await createReverb(context, context.destination, reverb)\n\nconst createReverb = async (context, output, impulse) => {\n  const impulseBuffer = await loadImpulse(context, reverbSamples[impulse])\n  const convolverNode = context.createConvolver()\n  convolverNode.buffer = impulseBuffer.buffer\n  convolverNode.connect(output)\n  return convolverNode\n}\n")),Object(a.b)("h3",{id:"sampler-v3"},"Sampler v3"),Object(a.b)("p",null,"Putting all of these concepts together, we can build a sampler."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const sampler = async (context, samples) => {\n  const buffers = await Promise.all(\n    Object.keys(samples).map((note) =>\n      fetch(samples[note])\n        .then((response) => response.arrayBuffer())\n        .then((arrayBuffer) => context.decodeAudioData(arrayBuffer))\n        .then((buffer) => Object.create({ note, buffer }))\n    )\n  )\n\n  const compressorNode = context.createDynamicsCompressor()\n  compressorNode.threshold.value = -50\n  compressorNode.knee.value = 40\n  compressorNode.ratio.value = 12\n  compressorNode.attack.value = 0\n  compressorNode.release.value = 0.25\n\n  const gainNode = context.createGain()\n\n  return (note, options) => {\n    const now = context.currentTime\n    const notes = typeof note == 'string' ? [note] : note\n    const defaults = { volume: 1, duration: Infinity }\n    const { volume, duration } = Object.assign(defaults, options)\n\n    notes.map((n) => {\n      const buffer = buffers.find((b) => b.note == n).buffer\n      const sourceNode = context.createBufferSource()\n      sourceNode.buffer = buffer\n      sourceNode.start()\n\n      const zero = 0.00001 // value must be positive for exponentialRamp\n      gainNode.gain.value = volume\n      gainNode.gain.exponentialRampToValueAtTime(\n        zero,\n        now + Math.min(duration, buffer.duration)\n      )\n\n      sourceNode.connect(gainNode)\n      gainNode.connect(compressorNode)\n      compressorNode.connect(context.destination)\n    })\n  }\n}\n\ntuplet.run(async (context) => {\n  const piano = await sampler(context, tuplet.sampleMap('samples/piano/'))\n\n  // Single C note\n  piano('C4', { volume: 0.5 })\n\n  // C major chord\n  piano(['C4', 'E4', 'G4'], { volume: 0.8, duration: 2 })\n})\n")),Object(a.b)("h2",{id:"learning"},"Learning"),Object(a.b)("p",null,"TODO: Mention that these functions are part of Tuplet, and we'll use them going\nforward."))}i.isMDXComponent=!0}}]);