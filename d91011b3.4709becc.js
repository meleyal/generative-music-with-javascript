(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{133:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return i})),t.d(n,"default",(function(){return l}));var r=t(1),a=t(6),o=(t(0),t(141)),s={title:"Phrases"},c={id:"music/phrases",title:"Phrases",description:"At it's most basic, we could represent a pattern as an array of notes:",source:"@site/book/music/phrases.md",permalink:"/book/music/phrases"},i=[{value:"Rings",id:"rings",children:[]},{value:"Resolution",id:"resolution",children:[]},{value:"Transforms",id:"transforms",children:[]},{value:"Generators",id:"generators",children:[]}],p={rightToc:i};function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"At it's most basic, we could represent a pattern as an array of notes:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const pattern = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5']\n")),Object(o.b)("p",null,"##\xa0Steps"),Object(o.b)("p",null,"To step through the pattern, we just need a counter to keep track of the current\nstep and use that as an index into the pattern array, then wrap around back to\nthe start when it reaches the last step:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const pattern = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5']\n\nlet step = 0\n\nsetInterval(() => {\n  console.log(`s${step} : ${pattern[step]}`)\n\n  if (step < pattern.length - 1) {\n    step += 1\n  } else {\n    step = 0\n  }\n}, 1000)\n")),Object(o.b)("p",null,"Recall that we already have our ",Object(o.b)("inlineCode",{parentName:"p"},"metronome()")," function. Rather than keeping\ntrack of the step ourselves, can we use metronome to update the step? Recall\nthat our metronome simply counts beats upwards from 0. It has no concept of\npattern length, so it would work for the first 16 beats then continue past the\nend of the pattern."),Object(o.b)("p",null,"We could extend our metronome to tick in units of 8, 16 etc. but this would be\nlimiting as it would prevent combining patterns of different lengths."),Object(o.b)("p",null,"It would be nice if we could pass our pattern our incrementing beat, and our\npattern would just know when it needed to loop back around. Enter rings!"),Object(o.b)("h2",{id:"rings"},"Rings"),Object(o.b)("p",null,"Rings (or ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Circular_buffer"}),"ring buffers"),") are a\nspecial type of array where the values 'loop'. With a regular array, accessing\nan element that's out of range returns undefined. Accessing an element beyond\nthe end of a ringed array 'wraps around' to give you back the element at the\nequivalent index from the start of the array. Another way to think about it is\nthat the ringed array repeats itself."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const array = ['A4', 'B4', 'C4']\narray[1] // => B4\narray[4] // => undefined\n\nconst fakeRing = ['A4', 'B4', 'C4'].concat(['A4', 'B4', 'C4'])\nfakeRing[1] // => B4\nfakeRing[4] // => B4\n")),Object(o.b)("p",null,"We can make our own ",Object(o.b)("inlineCode",{parentName:"p"},"ring()")," function that takes a regular array and returns a\nfunction we can use to access the array like a ring:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const ring = (arr) => {\n  const len = arr.length\n\n  return (index) => {\n    if (typeof index !== 'undefined') {\n      return arr[index % len]\n    } else {\n      return arr\n    }\n  }\n}\n\nconst r = ring(['A4', 'B4', 'C4'])\n\nr(0) == r(3) // => true\nr(1) == r(4) // => true\nr(2) == r(5) // => true\n")),Object(o.b)("p",null,"We can now plug our newly ringed pattern into our metronome and it will loop\nback around:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const { metronome, ring } = tuplet\n\nconst pattern = ring(['A4', 'B4', 'C4', 'D4'])\nconst metro = metronome(60)\n\nmetro.on('tick', (tick) => {\n  pattern(tick) // => A4, B4, C4, D4, A4, B4...\n})\n\nmetro.start()\n")),Object(o.b)("h2",{id:"resolution"},"Resolution"),Object(o.b)("p",null,"Resolution defines how fast a pattern plays back, relative to the current bpm,\ngiving you a way to control the speed of a pattern without altering the overall\nspeed of the music. This is useful to hear how a pattern sounds at double speed,\nhalf speed, or any resolution the sequencer supports."),Object(o.b)("p",null,"Our ",Object(o.b)("inlineCode",{parentName:"p"},"metronome()")," function already supports different resolutions. We can use\nthis to sequence two patterns at different speeds:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const { sampler, metronome, ring } = tuplet\n\n;(async () => {\n  const piano = await sampler('piano')\n  const metro = metronome(60)\n  const pattern1 = ring(['A4', 'B4', 'C4', 'D4'])\n  const pattern2 = ring(['E4', 'F4', 'G4', 'A4'])\n\n  metro.on('tick', (tick) => {\n    piano(pattern1(tick)) // => A4, B4, C4, D4, A4, B4...\n  })\n\n  metro.on('tick/16', (tick) => {\n    piano(pattern2(tick)) // => E4, F4, G4, A4, E4, F4...\n  })\n\n  metro.start()\n\n  // => A4, E4, F4, G4, A4, B4, E4, F4, G4, A4, C4, E4, F4...\n})()\n")),Object(o.b)("h2",{id:"transforms"},"Transforms"),Object(o.b)("p",null,"Being that our pattern is just an array, it's easy to copy and alter it:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const pattern = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5']\n\nconst pattern2 = pattern.slice(4, 8).reverse()\n\npattern2 // => ['C5', 'B4', 'A4', 'G4']\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"TODO: Expand: See Sequencing chapter.")),Object(o.b)("h2",{id:"generators"},"Generators"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"TODO: Research if Generator functions would be useful here.")),Object(o.b)("p",null,"It would be nice if we could avoid writing out all of our patterns by hand. This\nis a book on generative music after all! For this purpose, we'll introduce the\nconcept of \"generators\". In this context, a generator is just a name we'll give\nto something that produces a pattern (not to be confused with\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"}),"JavaScript generator functions"),")."),Object(o.b)("p",null,"Let's start simple and just generate a random sequence of notes from the C major\nscale. As we progress through the book, we'll explore more interesting ways of\ngenerating patterns."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const {\n  sampler,\n  metronome,\n  music,\n  util,\n  pipe,\n  scale,\n  limit,\n  ring,\n  transpose,\n  take,\n  shuffle,\n} = tuplet\n\n;(async () => {\n  const piano = await sampler('piano')\n  const metro = metronome(120)\n\n  const pattern1 = pipe(scale('cmaj'), limit('piano'), shuffle(), take(8))([])\n\n  const pattern2 = pipe(transpose(-5))(pattern1)\n\n  const ring1 = ring(pattern1)\n  const ring2 = ring(pattern2)\n\n  metro.on('tick', (tick) => {\n    piano(ring1(tick))\n    piano(ring2(tick))\n  })\n\n  metro.start()\n})()\n")))}l.isMDXComponent=!0},141:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return f}));var r=t(0),a=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=a.a.createContext({}),l=function(e){var n=a.a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):c({},n,{},e)),t},u=function(e){var n=l(e.components);return a.a.createElement(p.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},m=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(t),m=r,f=u["".concat(s,".").concat(m)]||u[m]||b[m]||o;return t?a.a.createElement(f,c({ref:n},p,{components:t})):a.a.createElement(f,c({ref:n},p))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=m;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=e,c.mdxType="string"==typeof e?e:r,s[1]=c;for(var p=2;p<o;p++)s[p]=t[p];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);